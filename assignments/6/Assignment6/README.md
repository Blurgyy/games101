# Assignment 6

- 完成的分数: **60 分** (`60 = 5 + 20 + 15 + 20`)
  - `[5 分]` 包括了 `CMakeLists.txt` 和所有的程序文件, 所有的实验结果图片都保存在 `/images` 目录下.
  - `[20 分]` 正确实现了光线与包围盒求交函数
  - `[15 分]` 正确实现了 BVH 加速的光线与场景求交
  - `[加分项 20 分]` 在文件 BVH.cpp 中实现了函数 `SAHPartition()`, 正确实现了 SAH 加速. 测试中使用了 32 个 bucket 实现 SAH 建立 BVH, 相对于 Naive BVH, 渲染时间减少了 `10%`.

***

- SAH 的实现方法:
  SAH 通过定义和最小化 cost 来实现优化. 对于凸包 N 的一个划分, SAH 定义其 cost 为 "$C_{trav} + \sum p_iC_i$", 其中 $C_{trav}$ 表示遍历数据结构的时间, $p_i$ 表示随机光线击中划分中第 i 个区域的概率, $C_i$ 代表第 i 个区域的 cost. 其中 SAH 做了下面的近似:
  - 随机光线击中第 i 个区域的概率 $p_i$ 被近似为第 i 个区域的表面积与整个凸包的表面积之比 $\frac{S_i}{S_N}$.
  - 第 i 个区域的损耗 $C_i$ 被近似为这一区域内的物体个数与每次相交时的计算量的乘积 $N_iC_{isect}$

  所以 SAH 可以通过遍历空间中每一个可能的划分, 计算它们的 cost, 并选取 cost 最小的划分作为本次使用的划分. 实际做法中为了加速这个过程, 使用了若干个桶来统计空间中物体所在的位置, 最后遍历桶与桶之间的位置作为划分点, 同样选取 cost 最小的划分.
- 时间开销对比:
  - 实验条件:
    - 打开 g++ O2 优化;
    - naive BVH 实现中的 `std::sort` 改为复杂度 O(n) 的 `std::nth_element`;
    - SAH 加速的 BVH 实现中, 桶的个数使用 32, 每次划分时, 在最长的轴上选择划分点.
  - 实验结果:
    - 作业中带的 bunny 模型:
      - naive BVH: 建树 `11 ms`, 渲染 `933 ms`
      - SVH 加速: 建树 `10 ms`, 渲染 `838 ms`(降低 10.2%)
      - [结果截图](images/time-diff-bunny.jpg)
    - 论坛中的同学发布的 armadillo 模型 (更大):
      - naive BVH: 建树 `258 ms`, 渲染 `13067 ms`
      - SVH 加速: 建树 `264 ms`, 渲染 `11032 ms`(降低 15.6%)
      - [结果截图](images/time-diff-armadillo.jpg)
  - 分析: naive BVH 的建树过程只要 O(n) 找到中位数即可, SVH 的建树过程还要加上计算 cost 的时间开销 (常数复杂度), 使用 bucket 可以降低这一常数; 建树之后由于 SVH 的树已经最小化了光线"被浪费"的概率, 所以在渲染过程中 SVH 更快. 上面两个测试可以看出 SVH 加速后, 渲染速度大致可以优化 10% 至 15%.

***

- 各个函数中实现的功能:
  - `IntersectP()`: 判断一条光线是否穿过一个包围盒. 分别在一个包围盒的三个对面上计算出 `tEnter` 和 `tExit`, 最后判断如果三组 `tEnter` 和 `tExit` 之间的交集不为空, 并且 `tExit` 大于 0, 则光线穿过了包围盒, 返回 `true`. 否则返回 `false`.
  - `getIntersection()`: 判断一条光线是否穿过 BVH Node, 如果穿过, 则对这一 BVH Node 的两个子节点递归调用自身. 如果当前的 BVH Node 没有子节点 (是叶子节点), 则判断光线与本叶子节点中的物体是否相交, 相交的话返回这一个相交点的信息.
  - `SAHPartition()`: 用于 SVH 加速 BVH 建树. 仍然递归建树, 每次划分节点时在最长的轴上选取划分点. 划分点的标准通过计算 cost 并选取 cost 最小的划分点来确定. 实现中使用了 32 个 buckets.
