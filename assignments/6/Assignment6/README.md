# Assignment 6

- 完成的分数: **60 分** (`60 = 5 + 20 + 15 + 20`)
  - `[5 分]` 包括了 `CMakeLists.txt` 和所有的程序文件, 所有的实验结果图片都保存在 `/images` 目录下.
  - `[20 分]` 正确实现了光线与包围盒求交函数
  - `[15 分]` 正确实现了 BVH 加速的光线与场景求交
  - `[加分项 20 分]` 在文件 BVH.cpp 中实现了函数 `SAHPartition()`, 正确实现了 SAH 加速. 测试中使用了 32 个 bucket 实现 SAH 建立 BVH, 相对于 Naive BVH, 渲染时间减少了 `10%`.

***

- SAH 的实现方法:
  SAH 通过定义和最小化 cost 来实现优化. 对于凸包 N 的一个划分, SAH 定义其 cost 为 "$C_{trav} + \sum p_iC_i$", 其中 $C_{trav}$ 表示遍历数据结构的时间, $p_i$ 表示随机光线击中划分中第 i 个区域的概率, $C_i$ 代表第 i 个区域的 cost. 其中 SAH 做了下面的近似:
  - 随机光线击中第 i 个区域的概率 $p_i$ 被近似为第 i 个区域的表面积与整个凸包的表面积之比 $\frac{S_i}{S_N}$.
  - 第 i 个区域的损耗 $C_i$ 被近似为这一区域内的物体个数与每次相交时的计算量的乘积 $N_iC_{isect}$

  所以 SAH 可以通过遍历空间中每一个可能的划分, 计算它们的 cost, 并选取 cost 最小的划分作为本次使用的划分. 实际做法中为了加速这个过程, 使用了若干个桶来统计空间中物体所在的位置, 最后遍历桶与桶之间的位置作为划分点, 同样选取 cost 最小的划分.
- 时间开销对比:
  - 实验条件:
    - 打开 g++ O2 优化, naive BVH 实现中的 `std::sort` 改为复杂度 O(n) 的 `std::nth_element`;
    - SAH 加速的 BVH 实现中, 桶的个数使用 32, 每次划分在最长的轴上选择划分点.
  - 实验结果:
    - 作业中带的 bunny 模型:
      - naive BVH: 建树 `10 ms`, 渲染 `1041 ms`
      - SVH 加速: 建树 `17 ms`, 渲染 `934 ms`(-10.3%)
    - 论坛中的同学发布的 armadillo 模型 (更大):
      - naive BVH: 建树 `267 ms`, 渲染 `15132 ms`
      - SVH 加速: 建树 `354 ms`, 渲染 `12570 ms`(-16.9%)
  - 分析: naive BVH 的建树过程只要 O(n) 找到中位数即可, SVH 的建树过程还有计算 cost 的时间开销, 使用 bucket 是一种加速方式, bucket 数量降低到 16 可以使 SVH 的建树比 naive BVH 更快; 建树之后由于 SVH 的树就是最小化了光线"被浪费"的概率, 所以渲染过程中 SVH 更快. 上面两个测试可以看出 SVH 加速后, 渲染时间大致可以降低多于 10%.

***

- 各个函数中实现的功能:
  - ``:
